{"version":3,"sources":["../src/index.tsx","../src/components/MapRenderer.tsx","../src/components/GameRenderer.tsx"],"sourcesContent":["import { render } from 'ink';\nimport type { Map as GameMap, World, Position } from '@atsu/choukai';\nimport type { BaseUnit, IUnitPosition } from '@atsu/atago';\nimport { MapRenderer } from './components/MapRenderer';\nimport { GameRenderer } from './components/GameRenderer';\nimport type { IGameRendererConfig } from './types';\n\nexport { MapRenderer, GameRenderer, IGameRendererConfig };\n\n// Convenience function to render a single map\nexport const renderMap = (\n  map: GameMap,\n  units?: Record<string, BaseUnit>,\n  options?: {\n    showCoordinates?: boolean;\n    cellWidth?: number;\n    showUnits?: boolean;\n    showTerrain?: boolean;\n    compactView?: boolean;\n    useColors?: boolean;\n  }\n) => {\n  const { waitUntilExit } = render(\n    <MapRenderer\n      map={map}\n      units={units}\n      {...options}\n    />\n  );\n\n  return waitUntilExit;\n};\n\n// Convenience function to render the entire game world\nexport const renderGame = (\n  world: World,\n  units?: Record<string, BaseUnit>,\n  config: IGameRendererConfig = {}\n) => {\n  const { waitUntilExit } = render(\n    <GameRenderer\n      world={world}\n      units={units}\n      config={config}\n    />\n  );\n\n  return waitUntilExit;\n};","import React, { useMemo, memo } from 'react';\nimport { Box, Text, Newline } from 'ink';\nimport type { Map as GameMap, Position } from '@atsu/choukai';\nimport type { BaseUnit, IUnitPosition } from '@atsu/atago';\n\ninterface MapRendererProps {\n  map: GameMap;\n  units?: Record<string, BaseUnit>;\n  showCoordinates?: boolean;\n  cellWidth?: number;\n  showUnits?: boolean;\n  showTerrain?: boolean;\n  compactView?: boolean;\n  useColors?: boolean;\n}\n\nconst TERRAIN_SYMBOLS: Record<string, string> = {\n  grass: '.',\n  water: '~',\n  mountain: '^',\n  forest: 't',\n  desert: '#',\n  road: '=',\n  plains: '.',\n  swamp: ':',\n  snow: '*',\n  sand: '-',\n};\n\nconst TERRAIN_COLORS: Record<string, string> = {\n  grass: 'gray',\n  water: 'blue',\n  mountain: 'white',\n  forest: 'green',\n  desert: 'yellow',\n  road: 'gray',\n  plains: 'cyan',\n  swamp: 'magenta',\n  snow: 'white',\n  sand: 'yellow',\n};\n\nconst UNIT_COLOR = 'green';\n\n// Single text component for entire map rendering to reduce component overhead\nexport const MapRenderer: React.FC<MapRendererProps> = memo(({\n  map,\n  units = {},\n  showCoordinates = true,\n  cellWidth = 1,\n  showUnits = true,\n  showTerrain = true,\n  compactView = true,\n  useColors = true,\n}) => {\n  // Generate the entire map as a single string to reduce component overhead\n  const mapDisplay = useMemo(() => {\n    // Create a map of unit positions for efficient lookup\n    const unitPositions = new Map<string, BaseUnit>();\n    if (showUnits) {\n      for (const unit of Object.values(units)) {\n        const positionData = unit.getPropertyValue<IUnitPosition>('position');\n        if (positionData && positionData.mapId === map.name) {\n          const posKey = `${positionData.position.x},${positionData.position.y}`;\n          unitPositions.set(posKey, unit);\n        }\n      }\n    }\n\n    const rows: Array<Array<{content: string, isUnit: boolean, terrain: string}>> = [];\n\n    // Generate the map display\n    for (let y = 0; y < map.height; y++) {\n      const row: Array<{content: string, isUnit: boolean, terrain: string}> = [];\n\n      if (showCoordinates) {\n        const coordStr = y.toString().padStart(2, ' ');\n        row.push({ content: compactView ? `${coordStr}|` : `${coordStr} |`, isUnit: false, terrain: 'grass' });\n      }\n\n      for (let x = 0; x < map.width; x++) {\n        let cellContent = '';\n        let isUnit = false;\n        let terrainType = 'grass';\n\n        // Efficiently check for a unit at this position\n        if (showUnits) {\n          const posKey = `${x},${y}`;\n          const unitAtPosition = unitPositions.get(posKey);\n\n          if (unitAtPosition) {\n            const unitName = unitAtPosition.name || unitAtPosition.id;\n            cellContent = unitName.charAt(0).toUpperCase();\n            isUnit = true;\n          }\n        }\n\n        if (!cellContent && showTerrain) {\n          const cell = map.getCell(x, y);\n          terrainType = cell?.terrain || 'grass';\n          cellContent = TERRAIN_SYMBOLS[terrainType] || '?';\n        }\n\n        // Pad the cell content to the desired width\n        if (cellWidth > 1) {\n          cellContent = cellContent.padEnd(cellWidth, ' ');\n        } else if (!compactView) {\n          cellContent += ' ';\n        }\n\n        row.push({ content: cellContent, isUnit, terrain: terrainType });\n      }\n\n      rows.push(row);\n    }\n\n    return rows;\n  }, [map, units, showCoordinates, cellWidth, showUnits, showTerrain, compactView]); // Removed useColors to avoid unnecessary updates\n\n  return (\n    <Box flexDirection=\"column\">\n      <Text bold>{`Map: ${map.name} (${map.width}x${map.height})`}</Text>\n      <Newline />\n      {mapDisplay.map((row, rowIndex) => {\n        // Group consecutive cells with the same color to reduce the number of Text components\n        const segments = [];\n        let currentSegment = '';\n        let currentColor: string | undefined = undefined;\n        let firstCell = true;\n\n        for (const cellData of row) {\n          const color = useColors\n            ? (cellData.isUnit ? UNIT_COLOR : TERRAIN_COLORS[cellData.terrain])\n            : undefined;\n\n          if (firstCell || color !== currentColor) {\n            if (!firstCell) {\n              segments.push({ content: currentSegment, color: currentColor || undefined });\n            }\n            currentSegment = cellData.content;\n            currentColor = color;\n            firstCell = false;\n          } else {\n            currentSegment += cellData.content;\n          }\n        }\n\n        // Add the last segment\n        if (currentSegment) {\n          segments.push({ content: currentSegment, color: currentColor });\n        }\n\n        return (\n          <Box key={rowIndex} flexDirection=\"row\">\n            {segments.map((segment, segIndex) => (\n              <Text key={segIndex} color={segment.color}>\n                {segment.content}\n              </Text>\n            ))}\n          </Box>\n        );\n      })}\n    </Box>\n  );\n});","import React, { memo, useMemo } from 'react';\nimport { Box, Text, Newline } from 'ink';\nimport type { Map as GameMap, World, Position } from '@atsu/choukai';\nimport type { BaseUnit, IUnitPosition } from '@atsu/atago';\nimport { MapRenderer } from './MapRenderer';\nimport type { IGameRendererConfig } from '../types';\n\ninterface GameRendererProps {\n  world: World;\n  units?: Record<string, BaseUnit>;\n  config: IGameRendererConfig\n}\n\n// Memoized unit positions display\nconst UnitPositionsDisplay = memo(({ units, showUnitPositions }: {\n  units: Record<string, BaseUnit>,\n  showUnitPositions?: boolean\n}) => {\n  if (!showUnitPositions || Object.keys(units).length === 0) {\n    return null;\n  }\n\n  return (\n    <Box flexDirection=\"column\" marginTop={1}>\n      <Text bold>Unit Positions:</Text>\n      {Object.entries(units).map(([unitId, unit]) => {\n        const positionData = unit.getPropertyValue('position');\n        if (positionData) {\n          const unitName = unit.name || unitId;\n          return (\n            <Text key={unitId}>\n              {unitName} ({unitId.substring(0, 8)}...) at {positionData.mapId} ({positionData.position.x}, {positionData.position.y})\n            </Text>\n          );\n        }\n        return null;\n      }).filter(Boolean)}\n    </Box>\n  );\n});\n\nexport const GameRenderer: React.FC<GameRendererProps> = memo(({\n  world,\n  units = {},\n  config = {}\n}) => {\n  // Memoize the maps to render to prevent unnecessary recalculations\n  const mapsToRender = useMemo(() => {\n    const maps = world.getAllMaps();\n    return config.selectedMap\n      ? maps.filter(map => map.name === config.selectedMap)\n      : maps;\n  }, [world, config.selectedMap]);\n\n  return (\n    <Box flexDirection=\"column\" padding={1}>\n      <Box flexDirection=\"row\" justifyContent=\"space-between\" marginBottom={1}>\n        <Text bold color=\"cyan\">Takao Engine - Game View</Text>\n        {/* Remove the constantly updating time to reduce flickering */}\n        {/* <Text color=\"gray\">{new Date().toLocaleTimeString()}</Text> */}\n      </Box>\n\n      {mapsToRender.length === 0 ? (\n        <Text color=\"yellow\">No maps available</Text>\n      ) : (\n        mapsToRender.map((map, index) => (\n          <Box key={map.name} flexDirection=\"column\" marginBottom={2}>\n            <MapRenderer\n              map={map}\n              units={units}\n              showCoordinates={true}\n              cellWidth={1}\n              showUnits={true}\n              showTerrain={true}\n              compactView={true}\n              useColors={true}\n            />\n\n            {index < mapsToRender.length - 1 && <Newline />}\n          </Box>\n        ))\n      )}\n      {/* Unit positions summary */}\n      <UnitPositionsDisplay units={units} showUnitPositions={config.showUnitPositions} />\n    </Box>\n  );\n});"],"mappings":"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","names":["import_ink","import_react","import_ink","import_jsx_runtime","import_jsx_runtime"]}